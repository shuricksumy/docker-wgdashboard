name: Check and Update Submodule
permissions:
  contents: write       # Required to push the update
  pull-requests: write  # Required to create/update PRs

on:
  schedule:
    - cron: '0 0 * * *'
  workflow_dispatch: ~

jobs:
  update-submodule:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          # Fetching with submodules and depth 0 ensures we have history for diffing
          submodules: true
          fetch-depth: 0
          token: ${{ secrets.GHCR_PAT }} # Use PAT here to ensure we can push submodules if needed

      - name: Update and Filter Submodule
        id: update
        run: |
          # 1. Get the current submodule Commit ID before update
          # (Assuming 'your-submodule-path' - adjust if you have multiple or a specific path)
          # We use 'git submodule status' to find the path automatically or you can hardcode it.
          SUBMODULE_PATH=$(git submodule | head -n1 | awk '{print $2}')
          
          echo "Detected submodule at: $SUBMODULE_PATH"
          OLD_COMMIT=$(git -C $SUBMODULE_PATH rev-parse HEAD)

          # 2. Update the submodule to remote latest
          git submodule update --remote --force

          NEW_COMMIT=$(git -C $SUBMODULE_PATH rev-parse HEAD)

          # 3. Check if the hash actually changed
          if [ "$OLD_COMMIT" == "$NEW_COMMIT" ]; then
            echo "No submodule updates found."
            echo "has_changes=false" >> $GITHUB_ENV
            exit 0
          fi

          echo "Submodule updated from $OLD_COMMIT to $NEW_COMMIT"

          # 4. Check what files changed inside the submodule
          # We check the diff in the submodule directory between old and new commit
          # We look for files that DO NOT end in .md
          cd $SUBMODULE_PATH
          CHANGES=$(git diff --name-only $OLD_COMMIT $NEW_COMMIT | grep -v '\.md$' || true)
          cd ..

          if [[ -n "$CHANGES" ]]; then
            echo "Significant changes found (excluding .md files)."
            echo "$CHANGES"
            echo "has_changes=true" >> $GITHUB_ENV
          else
            echo "Only .md files changed or no changes relevant. Reverting submodule update."
            # Reset submodule to old commit so we don't leave a dirty state
            git submodule update --checkout --force
            echo "has_changes=false" >> $GITHUB_ENV
          fi

      - name: Create or Update Pull Request
        if: env.has_changes == 'true'
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GHCR_PAT }}
          # FIXED BRANCH NAME: This is the key. 
          # If this branch exists, the action updates it (squashing previous runs).
          branch: auto/update-submodule
          base: main
          delete-branch: true
          title: "chore: Update submodule to latest"
          body: |
            This PR updates the submodule to the latest commit.
            
            - Auto-generated by GitHub Actions.
            - Updates existing PR if one is already open.
          commit-message: "chore: update submodule to latest version"
          labels: |
            submodule
            automated-pr
